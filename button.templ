package popui

import (
	"github.com/invopop/popui.go/classes"
	"github.com/invopop/popui.go/props"
	"github.com/invopop/popui.go/tailwind"
)

// ButtonGroup provides a wrapper around a set of horizontal buttons
// with a consistent gap between them, useful for actions in headers
// or footers.
templ ButtonGroup(opts ...props.ButtonGroup) {
	{{ btns := props.First(opts) }}
	<div
		if btns.ID != "" {
			id={ btns.ID }
		}
		class={
			tailwind.Merge(
				"flex items-center gap-2",
				buttonGroupAlignmentClasses(btns.Align),
				btns.Class,
			),
		}
		{ btns.Attributes... }
	>
		{ children... }
	</div>
}

// Button provides a button or anchor element styled as a button.
// If the Anchor property is set, it renders an <a> tag, otherwise a <button> tag.
// Supports sizes: "sm", "md" (default), "lg", and "icon"
// Supports variants: "primary", "secondary", "danger" and "transparent"
templ Button(p ...props.Button) {
	{{ btn := props.First(p) }}
	if btn.IsAnchor() {
		<a
			if btn.ID != "" {
				id={ btn.ID }
			}
			if btn.Href != "" {
				href={ btn.Href }
			}
			if btn.Target != "" {
				target={ btn.Target }
			}
			if btn.Rel != "" {
				rel={ btn.Rel }
			}
			if btn.Download {
				download
			}
			if btn.PopoverTarget != "" {
				popovertarget={ btn.PopoverTarget }
			}
			if btn.PopoverTargetAction != "" {
				popovertargetaction={ btn.PopoverTargetAction }
			}
			class={
				tailwind.Merge(
					buttonBaseClasses(),
					buttonClasses(btn.Variant, btn.Size),
					btn.Class,
				),
			}
			{ btn.Attributes... }
		>
			{ children... }
		</a>
	} else {
		<button
			if btn.ID != "" {
				id={ btn.ID }
			}
			if btn.Type != "" {
				type={ btn.Type }
			}
			if btn.Name != "" {
				name={ btn.Name }
			}
			if btn.Value != "" {
				value={ btn.Value }
			}
			if btn.Form != "" {
				form={ btn.Form }
			}
			if btn.Disabled {
				disabled
			}
			if btn.Autofocus {
				autofocus
			}
			if btn.PopoverTarget != "" {
				popovertarget={ btn.PopoverTarget }
			}
			if btn.PopoverTargetAction != "" {
				popovertargetaction={ btn.PopoverTargetAction }
			}
			class={
				tailwind.Merge(
					buttonBaseClasses(),
					buttonClasses(btn.Variant, btn.Size),
					btn.Class,
				),
			}
			{ btn.Attributes... }
		>
			{ children... }
		</button>
	}
}

func buttonBaseClasses() string {
	return "cursor-pointer inline-flex items-center justify-center font-medium font-sans relative tracking-tight px-2 py-[3px] rounded-md disabled:opacity-30 disabled:pointer-events-none border border-border-default-secondary text-base gap-1 shadow-button-default hover:border-border-default-secondary-hover active:border-border-default-secondary-hover active:shadow-button-pressed active:translate-y-[1px] box-border"
}

func buttonClasses(variant string, size string) string {
	return classes.Join(
		map[string]bool{
			// Variant classes
			"border-0 shadow-none hover:bg-background-default-tertiary-hover hover:shadow-button-default":                                                                                                            variant == props.ButtonVariantTransparent,
			"border-border-default-secondary bg-background-default-tertiary text-foreground-critical hover:border-transparent hover:bg-background-critical-bold hover:text-foreground-inverse [&_svg]:text-critical": variant == props.ButtonVariantDanger,
			"bg-background-accent text-foreground-inverse shadow-button-primary hover:bg-background-accent-hover active:bg-background-accent-hover":                                                                  variant == props.ButtonVariantPrimary,
			"border-0 bg-background-default-tertiary hover:bg-background-default-tertiary-hover":                                                                                                                     variant == props.ButtonVariantSecondary,
			// Size classes
			"text-sm rounded":             size == props.ButtonSizeSmall,
			"py-[5px] px-3 rounded-lg":    size == props.ButtonSizeLarge,
			"p-[5px] leading-none size-7": size == props.ButtonSizeIcon,
			// Icon color based on size
			"[&_svg]:text-icon":               size != props.ButtonSizeIcon && variant != props.ButtonVariantPrimary && variant != props.ButtonVariantDanger,
			"[&_svg]:text-icon-inverse":       size != props.ButtonSizeIcon && variant == props.ButtonVariantPrimary,
			"[&_svg]:text-foreground":         size == props.ButtonSizeIcon && variant != props.ButtonVariantPrimary,
			"[&_svg]:text-foreground-inverse": size == props.ButtonSizeIcon && variant == props.ButtonVariantPrimary,
		},
	)
}

func buttonGroupAlignmentClasses(alignment string) string {
	return classes.Join(
		map[string]bool{
			"justify-start":  alignment == props.ButtonGroupAlignLeft || alignment == "",
			"justify-center": alignment == props.ButtonGroupAlignCenter,
			"justify-end":    alignment == props.ButtonGroupAlignRight,
		},
	)
}
